// Code generated by "kvschema"; DO NOT EDIT.

package docs

import (
	"github.com/google/note-maps/kv"
)

// Schema provides entities, components, and indexes backed by a key-value
// store.
//
// Usage:
//
//   d, err := Schema{Store: store}.DocumentComponent(0).Scan([]kv.Entity{7, 42})
//
type Schema struct {
	Store kv.Store
}

// DocumentComponent manages a map from entities to Document values.
type DocumentComponent struct {
	s      kv.Store
	prefix kv.Prefix
}

// DocumentComponent returns a DocumentComponent rooted at the given parent.
func (s *Schema) DocumentComponent(parent kv.Entity) *DocumentComponent {
	var prefix kv.Prefix
	return &DocumentComponent{
		s:      s.Store,
		prefix: prefix.ConcatEntityComponent(parent, DocumentPrefix),
	}
}

// Set sets the Document associated with e to v.
//
// Corresponding indexes are updated.
func (c *DocumentComponent) Set(e kv.Entity, v *Document) error {
	ek := c.prefix.ConcatEntity(e)
	var old Document
	if err := c.s.Get(ek, old.Decode); err != nil {
		return err
	}
	if err := c.s.Set(ek, v.Encode()); err != nil {
		return err
	}
	var (
		lek = len(ek)
		ik  = c.prefix.ConcatEntityComponent(0, kv.Component(0))
		lik = len(ik)
		es  kv.EntitySlice
	)

	// Update Title index
	ik = ik[:lek].AppendComponent(TitlePrefix)
	for _, iv := range old.IndexTitle() {
		ik = append(ik[:lik], iv.Encode()...)
		if err := c.s.Get(ik, es.Decode); err != nil {
			return err
		}
		if es.Remove(e) {
			if err := c.s.Set(ik, es.Encode()); err != nil {
				return err
			}
		}
	}
	for _, iv := range v.IndexTitle() {
		ik = append(ik[:lik], iv.Encode()...)
		if err := c.s.Get(ik, es.Decode); err != nil {
			return err
		}
		if es.Insert(e) {
			if err := c.s.Set(ik, es.Encode()); err != nil {
				return err
			}
		}
	}
	return nil
}

// Scan returns a Document for each entity in es.
//
// If the underlying storage returns an empty value with no error for keys that
// do not exist, and Document.Decode() can decode an empty byte slice, then a
// query for entities that are not associated with a Document should return no
// errors.
func (c *DocumentComponent) Scan(es []kv.Entity) ([]Document, error) {
	result := make([]Document, len(es))
	for i, e := range es {
		err := c.s.Get(c.prefix.ConcatEntity(e), (&result[i]).Decode)
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// LookupByTitle returns entities with Document
// values that return a matching kv.String from their IndexTitle method.
//
// The returned EntitySlice is already sorted.
func (c *DocumentComponent) LookupByTitle(v kv.String) (kv.EntitySlice, error) {
	key := c.prefix.ConcatEntityComponentBytes(0, TitlePrefix, v.Encode())
	var es kv.EntitySlice
	return es, c.s.Get(key, es.Decode)
}

type TitleCursor struct {
	Value  kv.String
	Offset int
}

// AllByTitle reads entities associated with Document values
// ordered by Title.
//
// Reading begins at cursor, and ends when the length of the returned Entity
// slice is less than n. When reading is not complete, cursor is updated such
// that using it in a subequent call to ByTitle would return next n
// entities.
func (c *DocumentComponent) ByTitle(cursor *TitleCursor, n int) (es []kv.Entity, err error) {
	iter := c.s.PrefixIterator(c.prefix.ConcatEntityComponent(0, TitlePrefix))
	defer iter.Discard()
	iter.Seek(cursor.Value.Encode())
	if !iter.Valid() {
		return
	}
	var buf kv.EntitySlice
	if err = iter.Value(buf.Decode); err != nil {
		return
	}
	if cursor.Offset < len(buf) {
		es = append(es, buf[cursor.Offset:]...)
		if len(es) >= n {
			cursor.Offset += n
			if len(es) > n {
				es = es[:n]
			}
			return
		}
	}
	for iter.Next(); iter.Valid(); iter.Next() {
		if err = iter.Value(buf.Decode); err != nil {
			return
		}
		es = append(es, buf...)
		if len(es) >= n {
			err = cursor.Value.Decode(iter.Key())
			cursor.Offset = len(buf) - (len(es) - n)
			if len(es) > n {
				es = es[:n]
			}
			return
		}
	}
	return
}
